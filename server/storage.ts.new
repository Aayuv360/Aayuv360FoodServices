import {
  type User, type InsertUser, type Meal, type InsertMeal,
  type Subscription, type InsertSubscription, type Order, type InsertOrder,
  type OrderItem, type CartItem, type InsertCartItem,
  type Review, type InsertReview,
  type CustomMealPlan, type Address, type InsertAddress
} from "@shared/schema";
import { milletMeals } from "./mealItems";
import { CurryOption } from "../shared/mongoModels";
import * as expressSession from "express-session";
import createMemoryStore from "memorystore";
import { mongoStorage } from './mongoStorage';

// Define the storage interface
export interface IStorage {
  // Session store
  sessionStore: expressSession.Store;
  
  // User operations
  getUser(id: number): Promise<User | undefined>;
  getUserByUsername(username: string): Promise<User | undefined>;
  getUserByEmail(email: string): Promise<User | undefined>;
  createUser(user: InsertUser): Promise<User>;
  updateUser(id: number, user: Partial<User>): Promise<User | undefined>;
  getAllUsers(): Promise<User[]>;
  
  // Meal operations
  getMeal(id: number): Promise<Meal | undefined>;
  getAllMeals(): Promise<Meal[]>;
  getMealsByType(mealType: string): Promise<Meal[]>;
  getMealsByDietaryPreference(preference: string): Promise<Meal[]>;
  createMeal(meal: InsertMeal): Promise<Meal>;
  updateMeal(id: number, meal: Partial<Meal>): Promise<Meal | undefined>;
  
  // Subscription operations
  getSubscription(id: number): Promise<Subscription | undefined>;
  getSubscriptionsByUserId(userId: number): Promise<Subscription[]>;
  createSubscription(subscription: InsertSubscription): Promise<Subscription>;
  updateSubscription(id: number, subscription: Partial<Subscription>): Promise<Subscription | undefined>;
  getAllSubscriptions(): Promise<Subscription[]>;
  
  // Custom Meal Plan operations
  getCustomMealPlans(subscriptionId: number): Promise<CustomMealPlan[]>;
  createCustomMealPlan(customMealPlan: any): Promise<CustomMealPlan>;
  deleteCustomMealPlan(id: number): Promise<boolean>;
  
  // Order operations
  getOrder(id: number): Promise<Order | undefined>;
  getOrdersByUserId(userId: number): Promise<Order[]>;
  createOrder(order: InsertOrder): Promise<Order>;
  updateOrderStatus(id: number, status: string): Promise<Order | undefined>;
  getAllOrders(): Promise<Order[]>;
  
  // Order Item operations
  getOrderItems(orderId: number): Promise<OrderItem[]>;
  createOrderItem(orderItem: any): Promise<OrderItem>;
  getAllOrderItems(): Promise<OrderItem[]>;
  
  // User Preferences operations
  getUserPreferences(userId: number): Promise<any | undefined>;
  createUserPreferences(preferences: any): Promise<any>;
  updateUserPreferences(userId: number, preferences: any): Promise<any | undefined>;
  
  // Cart operations
  getCartItems(userId: number): Promise<CartItem[]>;
  addToCart(cartItem: InsertCartItem): Promise<CartItem>;
  updateCartItemQuantity(id: number, quantity: number): Promise<CartItem | undefined>;
  updateCartItem(id: number, updates: Partial<CartItem>): Promise<CartItem | undefined>;
  removeFromCart(id: number): Promise<boolean>;
  clearCart(userId: number): Promise<boolean>;
  
  // Review operations
  getReviewsByMealId(mealId: number): Promise<Review[]>;
  getReviewsByUserId(userId: number): Promise<Review[]>;
  createReview(review: InsertReview): Promise<Review>;
  getAllReviews(): Promise<Review[]>;
  
  // Address operations
  getAddresses(userId: number): Promise<Address[]>;
  getAddressById(id: number): Promise<Address | undefined>;
  createAddress(address: InsertAddress): Promise<Address>;
  updateAddress(id: number, address: Partial<Address>): Promise<Address | undefined>;
  deleteAddress(id: number): Promise<boolean>;
  
  // Curry Option operations
  getCurryOptions(): Promise<any[]>;
  getCurryOption(id: string): Promise<any | undefined>;
  createCurryOption(curryOption: any): Promise<any>;
  updateCurryOption(id: string, curryOption: any): Promise<any | undefined>;
  deleteCurryOption(id: string): Promise<boolean>;
}

// In-memory storage implementation for development and testing
export class MemStorage implements IStorage {
  private users: Map<number, User> = new Map();
  private meals: Map<number, Meal> = new Map();
  private subscriptions: Map<number, Subscription> = new Map();
  private customMealPlans: Map<number, CustomMealPlan> = new Map();
  private orders: Map<number, Order> = new Map();
  private orderItems: Map<number, OrderItem> = new Map();
  private userPreferences: Map<number, any> = new Map();
  private cartItems: Map<number, CartItem> = new Map();
  private reviews: Map<number, Review> = new Map();
  private addresses: Map<number, Address> = new Map();
  private curryOptions: Map<string, any> = new Map();
  
  // Session store for express-session
  sessionStore: expressSession.Store;
  
  // Auto-incrementing IDs
  private userId: number = 1;
  private mealId: number = 1;
  private subscriptionId: number = 1;
  private customMealPlanId: number = 1;
  private orderId: number = 1;
  private orderItemId: number = 1;
  private userPreferencesId: number = 1;
  private cartItemId: number = 1;
  private reviewId: number = 1;
  private addressId: number = 1;
  
  constructor() {
    const MemoryStore = createMemoryStore(expressSession);
    this.sessionStore = new MemoryStore({
      checkPeriod: 86400000 // prune expired entries every 24h
    });
    
    // Initialize with sample data
    this.initializeSampleMeals();
  }
  
  private initializeSampleMeals(): void {
    // Add sample meals from mealItems.ts
    for (const meal of milletMeals) {
      this.meals.set(this.mealId, { ...meal, id: this.mealId++, available: true });
    }
  }
  
  // Basic implementation of required methods with minimal functionality
  async getUser(id: number): Promise<User | undefined> {
    return this.users.get(id);
  }
  
  async getUserByUsername(username: string): Promise<User | undefined> {
    return Array.from(this.users.values()).find(user => user.username === username);
  }
  
  async getUserByEmail(email: string): Promise<User | undefined> {
    return Array.from(this.users.values()).find(user => user.email === email);
  }
  
  async createUser(user: InsertUser): Promise<User> {
    const id = this.userId++;
    const newUser: User = { ...user, id, role: 'user', createdAt: new Date() };
    this.users.set(id, newUser);
    return newUser;
  }
  
  async updateUser(id: number, user: Partial<User>): Promise<User | undefined> {
    const existingUser = this.users.get(id);
    if (!existingUser) return undefined;
    
    const updatedUser: User = { ...existingUser, ...user };
    this.users.set(id, updatedUser);
    return updatedUser;
  }
  
  async getMeal(id: number): Promise<Meal | undefined> {
    return this.meals.get(id);
  }
  
  async getAllMeals(): Promise<Meal[]> {
    return Array.from(this.meals.values());
  }
  
  async getMealsByType(mealType: string): Promise<Meal[]> {
    return Array.from(this.meals.values()).filter(meal => meal.type === mealType);
  }
  
  async getMealsByDietaryPreference(preference: string): Promise<Meal[]> {
    return Array.from(this.meals.values()).filter(meal => meal.dietaryInfo.includes(preference));
  }
  
  async createMeal(meal: InsertMeal): Promise<Meal> {
    const id = this.mealId++;
    const newMeal: Meal = { ...meal, id, available: true };
    this.meals.set(id, newMeal);
    return newMeal;
  }
  
  async updateMeal(id: number, meal: Partial<Meal>): Promise<Meal | undefined> {
    const existingMeal = this.meals.get(id);
    if (!existingMeal) return undefined;
    
    const updatedMeal: Meal = { ...existingMeal, ...meal };
    this.meals.set(id, updatedMeal);
    return updatedMeal;
  }
  
  async getSubscription(id: number): Promise<Subscription | undefined> {
    return this.subscriptions.get(id);
  }
  
  async getSubscriptionsByUserId(userId: number): Promise<Subscription[]> {
    return Array.from(this.subscriptions.values()).filter(sub => sub.userId === userId);
  }
  
  async createSubscription(subscription: InsertSubscription): Promise<Subscription> {
    const id = this.subscriptionId++;
    const newSubscription: Subscription = { ...subscription, id };
    this.subscriptions.set(id, newSubscription);
    return newSubscription;
  }
  
  async updateSubscription(id: number, subscription: Partial<Subscription>): Promise<Subscription | undefined> {
    const existingSubscription = this.subscriptions.get(id);
    if (!existingSubscription) return undefined;
    
    const updatedSubscription: Subscription = { ...existingSubscription, ...subscription };
    this.subscriptions.set(id, updatedSubscription);
    return updatedSubscription;
  }
  
  async getAllSubscriptions(): Promise<Subscription[]> {
    return Array.from(this.subscriptions.values());
  }
  
  async getCustomMealPlans(subscriptionId: number): Promise<CustomMealPlan[]> {
    return Array.from(this.customMealPlans.values()).filter(plan => plan.subscriptionId === subscriptionId);
  }
  
  async createCustomMealPlan(customMealPlan: any): Promise<CustomMealPlan> {
    const id = this.customMealPlanId++;
    const newCustomMealPlan: CustomMealPlan = { ...customMealPlan, id };
    this.customMealPlans.set(id, newCustomMealPlan);
    return newCustomMealPlan;
  }
  
  async deleteCustomMealPlan(id: number): Promise<boolean> {
    return this.customMealPlans.delete(id);
  }
  
  async getOrder(id: number): Promise<Order | undefined> {
    return this.orders.get(id);
  }
  
  async getOrdersByUserId(userId: number): Promise<Order[]> {
    return Array.from(this.orders.values()).filter(order => order.userId === userId);
  }
  
  async createOrder(order: InsertOrder): Promise<Order> {
    const id = this.orderId++;
    const newOrder: Order = { ...order, id, status: 'pending', createdAt: new Date() };
    this.orders.set(id, newOrder);
    return newOrder;
  }
  
  async updateOrderStatus(id: number, status: string): Promise<Order | undefined> {
    const existingOrder = this.orders.get(id);
    if (!existingOrder) return undefined;
    
    const updatedOrder: Order = { ...existingOrder, status: status as any };
    this.orders.set(id, updatedOrder);
    return updatedOrder;
  }
  
  async getAllOrders(): Promise<Order[]> {
    return Array.from(this.orders.values());
  }
  
  async getOrderItems(orderId: number): Promise<OrderItem[]> {
    return Array.from(this.orderItems.values()).filter(item => item.orderId === orderId);
  }
  
  async createOrderItem(orderItem: any): Promise<OrderItem> {
    const id = this.orderItemId++;
    const newOrderItem: OrderItem = { ...orderItem, id };
    this.orderItems.set(id, newOrderItem);
    return newOrderItem;
  }
  
  async getAllOrderItems(): Promise<OrderItem[]> {
    return Array.from(this.orderItems.values());
  }
  
  async getUserPreferences(userId: number): Promise<any | undefined> {
    return this.userPreferences.get(userId);
  }
  
  async createUserPreferences(preferences: any): Promise<any> {
    const id = this.userPreferencesId++;
    const newPreferences = { ...preferences, id };
    this.userPreferences.set(preferences.userId, newPreferences);
    return newPreferences;
  }
  
  async updateUserPreferences(userId: number, preferences: any): Promise<any | undefined> {
    const existingPreferences = this.userPreferences.get(userId);
    if (!existingPreferences) return undefined;
    
    const updatedPreferences = { ...existingPreferences, ...preferences };
    this.userPreferences.set(userId, updatedPreferences);
    return updatedPreferences;
  }
  
  async getCartItems(userId: number): Promise<CartItem[]> {
    return Array.from(this.cartItems.values()).filter(item => item.userId === userId);
  }
  
  async addToCart(cartItem: InsertCartItem): Promise<CartItem> {
    // Check if item already exists in cart (same user, meal, and curry option)
    const existingItems = Array.from(this.cartItems.values()).filter(
      item => item.userId === cartItem.userId && 
             item.mealId === cartItem.mealId &&
             item.curryOptionId === cartItem.curryOptionId
    );
    
    if (existingItems.length > 0) {
      const existingItem = existingItems[0];
      const updatedItem: CartItem = {
        ...existingItem,
        quantity: existingItem.quantity + cartItem.quantity
      };
      this.cartItems.set(existingItem.id, updatedItem);
      return updatedItem;
    }
    
    const id = this.cartItemId++;
    const newCartItem: CartItem = { ...cartItem, id };
    this.cartItems.set(id, newCartItem);
    return newCartItem;
  }
  
  async updateCartItemQuantity(id: number, quantity: number): Promise<CartItem | undefined> {
    const existingItem = this.cartItems.get(id);
    if (!existingItem) return undefined;
    
    const updatedItem: CartItem = { ...existingItem, quantity };
    this.cartItems.set(id, updatedItem);
    return updatedItem;
  }
  
  async updateCartItem(id: number, updates: Partial<CartItem>): Promise<CartItem | undefined> {
    const existingItem = this.cartItems.get(id);
    if (!existingItem) return undefined;
    
    const updatedItem: CartItem = { ...existingItem, ...updates };
    this.cartItems.set(id, updatedItem);
    return updatedItem;
  }
  
  async removeFromCart(id: number): Promise<boolean> {
    return this.cartItems.delete(id);
  }
  
  async clearCart(userId: number): Promise<boolean> {
    const cartItems = Array.from(this.cartItems.values()).filter(item => item.userId === userId);
    for (const item of cartItems) {
      this.cartItems.delete(item.id);
    }
    return true;
  }
  
  async getReviewsByMealId(mealId: number): Promise<Review[]> {
    return Array.from(this.reviews.values()).filter(review => review.mealId === mealId);
  }
  
  async getReviewsByUserId(userId: number): Promise<Review[]> {
    return Array.from(this.reviews.values()).filter(review => review.userId === userId);
  }
  
  async createReview(review: InsertReview): Promise<Review> {
    const id = this.reviewId++;
    const newReview: Review = { ...review, id, createdAt: new Date() };
    this.reviews.set(id, newReview);
    return newReview;
  }
  
  async getAllReviews(): Promise<Review[]> {
    return Array.from(this.reviews.values());
  }
  
  async getAddresses(userId: number): Promise<Address[]> {
    return Array.from(this.addresses.values()).filter(address => address.userId === userId);
  }
  
  async getAddressById(id: number): Promise<Address | undefined> {
    return this.addresses.get(id);
  }
  
  async createAddress(address: InsertAddress): Promise<Address> {
    const id = this.addressId++;
    const newAddress: Address = { ...address, id, createdAt: new Date() };
    this.addresses.set(id, newAddress);
    return newAddress;
  }
  
  async updateAddress(id: number, address: Partial<Address>): Promise<Address | undefined> {
    const existingAddress = this.addresses.get(id);
    if (!existingAddress) return undefined;
    
    const updatedAddress: Address = { ...existingAddress, ...address };
    this.addresses.set(id, updatedAddress);
    return updatedAddress;
  }
  
  async deleteAddress(id: number): Promise<boolean> {
    return this.addresses.delete(id);
  }
  
  async getCurryOptions(): Promise<any[]> {
    return Array.from(this.curryOptions.values());
  }
  
  async getCurryOption(id: string): Promise<any | undefined> {
    return this.curryOptions.get(id);
  }
  
  async createCurryOption(curryOption: any): Promise<any> {
    this.curryOptions.set(curryOption.id, curryOption);
    return curryOption;
  }
  
  async updateCurryOption(id: string, curryOption: any): Promise<any | undefined> {
    if (!this.curryOptions.has(id)) return undefined;
    
    const updatedOption = { ...this.curryOptions.get(id), ...curryOption };
    this.curryOptions.set(id, updatedOption);
    return updatedOption;
  }
  
  async deleteCurryOption(id: string): Promise<boolean> {
    return this.curryOptions.delete(id);
  }
}

// Initialize storage with MongoDB, but have MemStorage as fallback
declare global {
  var useMemoryFallback: boolean;
}

// Create a fallback memory storage instance
const memStorage = new MemStorage();

// Export a proxy to the current storage implementation
export const storage = new Proxy({} as IStorage, {
  get: (target, prop) => {
    // Always get the latest storage implementation
    return global.useMemoryFallback 
      ? memStorage[prop as keyof IStorage]
      : mongoStorage[prop as keyof IStorage];
  }
});

// Let other modules change the storage implementation
export function createFallbackStorage(): IStorage {
  console.log('Activating fallback in-memory storage');
  global.useMemoryFallback = true;
  return memStorage;
}